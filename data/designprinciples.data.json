[
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Optimize build and release processes",
        "context": "From provisioning with Infrastructure as Code, to build and releases with CI/CD pipelines, to automated testing, embrace software engineering disciplines across your entire environment. This approach ensures the creation and management of environments throughout the software development lifecycle is consistent, repeatable, and enables early detection of issues.",
        "id": "dp_opex_1"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Monitor entire system and understand operational health",
        "context": "Implement systems and processes to monitor build and release processes, infrastructure health, and application health. Telemetry is critical to understanding the health of a workload and whether the service is meeting the business goals.",
        "id": "dp_opex_2"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Rehearse recovery and practice failure",
        "context": "Run DR drills on regular cadence and use chaos engineering practices to identify and remediate weak points in application reliability. Regular rehearsal of failure will validate the effectiveness of recovery processes and ensure teams are familiar with their responsibilities.",
        "id": "dp_opex_3"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Embrace operational improvement",
        "context": "Continuously evaluate and refine operational procedures and tasks, while striving to reduce complexity and ambiguity. This approach enables an organization to evolve processes over time, optimizing inefficiencies and learning from failures.",
        "id": "dp_opex_4"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Use loosely coupled architecture",
        "context": "Enable teams to independently test, deploy, and update their systems on demand without depending on other teams for support, services, resources, or approvals.",
        "id": "dp_opex_5"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Business Requirements",
        "context": "Reliability is a subjective concept and for an application to be appropriately reliable it must reflect the business requirements surrounding it. For example, a mission-critical application with a 99.999% SLA requires a higher level of reliability that another application with an SLA of 95%. There are obvious financial and opportunity cost implications for introducing greater reliability and high availability, and this trade-off should be carefully considered.",
        "id": "dp_reliability_1"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Failure",
        "context": "Failure is impossible to avoid in a highly distributed multi-tenant environment like Azure. By anticipating failures, from individual components to entire Azure regions, a solution can be developed in a resilient way to increase reliability.",
        "id": "dp_reliability_2"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "context": "Before issues impacting application reliability can be mitigated, they must first be detected. By monitoring the operation of an application relative to a known healthy state it becomes possible to detect or even predict reliability issues, allowing for swift remedial action to be taken.",
        "title": "Observe Application Health",
        "id": "dp_reliability_3"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Drive Automation",
        "context": "One of the leading causes of application downtime is human error, whether that be due to the deployment of insufficiently tested software to misconfiguration. To minimize the possibility and impact of human errors, it is vital to strive for automation in all aspects of a cloud solution to improve reliability; automated testing, deployment, and management.",
        "id": "dp_reliability_4"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Self-Healing",
        "context": "Self Healing describes a system's ability to deal with failures automatically through pre-defined remediation protocols connected to failure modes within the solution. It is an advanced concept that requires a high level of system maturity with monitoring and automation, but should be an aspiration from inception to maximise reliability.",
        "id": "dp_reliability_6"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Scale-out",
        "context": "Scale-out is a concept that focuses on a system's ability to respond to demand through horizontal growth. This means that as traffic grows, _more_ resource units are added in parallel instead of increasing the size of the existing resources. A systems ability to handle expected and unexpected traffic increases through scale-units is essential to overall reliability and further reduces the impact of a single resource failure.",
        "id": "dp_reliability_5"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Plan resources and determine how to harden them",
        "context": "Ensure that security is taken into account when resources used by this workload are planned, and that it's understood how individual cloud services are protected. Use a service enablement framework to evaluate.",
        "id": "dp_security_1"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Automate and use least privilege",
        "context": "Implement least privilege throughout the application and control plane to protect against data exfiltration and malitious actor scenarios. Drive automation through DevSecOps to minimize the need for human interaction.",
        "id": "dp_security_2"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Classify and encrypt Data",
        "context": "Classify data according to risk and apply industry standard encryption at rest and in transit holistically, ensuring keys and certificates are stored securely and managed properly.",
        "id": "dp_security_3"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Monitor security of entire system and plan incident responses",
        "context": "Correlate security and audit events to model application health and identify active threats. Establish automated and manual procedures to respond to incidents leveraging SIEM tooling for tracking.",
        "id": "dp_security_4"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Identify and protect endpoints",
        "context": "Monitor and protect the network integrity of internal and external endpoints through security appliances, such as firewalls or web application firewalls. Use industry standard approaches to protect against common attack vectors, such as DDoS (e.g. SlowLoris).",
        "id": "dp_security_5"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Protect against code level vulnerabilities",
        "context": "Identify and mitigate code-level vulnerabilities (e.g. cross-site scripting, SQL injection). Regularly incorporate security fixes and patching of all parts of the codebase, including dependencies, into the operational lifecycle.",
        "id": "dp_security_6"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "security"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Model and test against potential threats",
        "context": "Establish procedures to identify and mitigate known threats. Use penetration testing to verify threat mitigation, as well as static code analysis and code scanning to detect and prevent future vulnerabilities.",
        "id": "dp_security_7"
    }
]
