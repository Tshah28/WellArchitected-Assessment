[
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Optimize build and release processes",
        "context": "From provisioning with Infrastructure as Code, to build and releases with CI/CD pipelines, to automated testing, embrace software engineering disciplines across your entire environment. This approach ensures the creation and management of environments throughout the software development lifecycle is consistent, repeatable, and enables early detection of issues.",
        "id": "dp_opex_1"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Monitor entire system and understand operational health",
        "context": "Implement systems and processes to monitor build and release processes, infrastructure health, and application health. Telemetry is critical to understanding the health of a workload and whether the service is meeting the business goals.",
        "id": "dp_opex_2"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Rehearse recovery and practice failure",
        "context": "Run DR drills on regular cadence and use chaos engineering practices to identify and remediate weak points in application reliability. Regular rehearsal of failure will validate the effectiveness of recovery processes and ensure teams are familiar with their responsibilities.",
        "id": "dp_opex_3"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Embrace operational improvement",
        "context": "Continuously evaluate and refine operational procedures and tasks, while striving to reduce complexity and ambiguity. This approach enables an organization to evolve processes over time, optimizing inefficiencies and learning from failures.",
        "id": "dp_opex_4"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "operationalexcellence"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Use loosely coupled architecture",
        "context": "Enable teams to independently test, deploy, and update their systems on demand without depending on other teams for support, services, resources, or approvals.",
        "id": "dp_opex_5"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Business Requirements",
        "context": "Reliablilty is a subjective concept. A reliable application performs in a way that is in line with the business requirements surrounding it. For one mission-critical application that may mean a 99.999% SLA, where for another 95% is perfectly acceptable. Considering the cost implications of extremely high availability, this is a tradeoff that should be carefully made.",
        "id": "dp_reliability_1"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Failure",
        "context": "Failure is impossible to avoid in a highly distributed environment like the cloud. By anticipating failures from individual components to entire Azure regions, a solution can be developed in a resilient way to increase reliability.",
        "id": "dp_reliability_2"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "context": "To mitigate issues that pose a threat to application reliability, they must first be detected. By monitoring the state of the application and having a deep understanding of the causes and effects of failures, swift (automated) action can be taken to prevent outages.",
        "title": "Observe Application Health",
        "id": "dp_reliability_3"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Drive Automation",
        "context": "One of the leading causes of downtime is human error. This may be insufficiently tested software being deployed, operator errors during deployment, or misconfigurations. To minimize the impact of human errors and improve reliability, one should strive for automation in all aspects of a cloud solution: Automated testing, automated deployment, automated management.",
        "id": "dp_reliability_4"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Self-Healing",
        "context": "Self Healing describes a system's capability of dealing with failures in an automated way by having a pre-defined remediation protocol connected to failure modes in the solution. This is a more advanced concept that can only work if a high level of maturity in monitoring and automation has been reached, but should be taken as a principal from the design phase onward.",
        "id": "dp_reliability_6"
    },
    {
        "type": "Design Principles",
        "pillars": [
            "reliability"
        ],
        "lens": "application",
        "category": "General",
        "subCategory": "Unassigned",
        "title": "Design for Scale-out",
        "context": "Scale-out is a concept that focuses on horizontal growth. This means that as traffic grows, _more_ resources are added in parallel instead of increasing the size of the existing resources. This method of scaling is generally cheaper but more importantly, it reduces the impact of a single resource failure making the solution more resilient.",
        "id": "dp_reliability_5"
    }
]
